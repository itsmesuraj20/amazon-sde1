# Complete DSA Question Bank for Top Tech Companies

## Arrays (50 Questions)

### Easy (1-15)
1. **Two Sum** - Find two numbers that add up to target
2. **Best Time to Buy and Sell Stock** - Maximum profit from one transaction
3. **Contains Duplicate** - Check if array contains duplicates
4. **Maximum Subarray** - Find contiguous subarray with largest sum
5. **Move Zeroes** - Move all zeros to end while maintaining order
6. **Plus One** - Add one to number represented as array
7. **Remove Duplicates from Sorted Array** - Remove duplicates in-place
8. **Merge Sorted Array** - Merge two sorted arrays in-place
9. **Intersection of Two Arrays II** - Find intersection with duplicates
10. **Single Number** - Find number that appears once
11. **Majority Element** - Find element appearing more than n/2 times
12. **Rotate Array** - Rotate array to right by k steps
13. **Valid Mountain Array** - Check if array forms mountain
14. **Find All Numbers Disappeared** - Find missing numbers from 1 to n
15. **Third Maximum Number** - Find third largest distinct number

### Medium (16-35)
16. **3Sum** - Find all unique triplets that sum to zero
17. **Container With Most Water** - Find max area container
18. **Product of Array Except Self** - Product excluding current element
19. **Spiral Matrix** - Return matrix elements in spiral order
20. **Rotate Image** - Rotate 2D matrix 90 degrees clockwise
21. **Group Anagrams** - Group strings that are anagrams
22. **Find Peak Element** - Find peak using binary search
23. **Search in Rotated Sorted Array** - Binary search in rotated array
24. **Sort Colors** - Sort array of 0s, 1s, and 2s
25. **Subarray Sum Equals K** - Count subarrays with sum k
26. **Next Permutation** - Find lexicographically next permutation
27. **Merge Intervals** - Merge overlapping intervals
28. **Insert Interval** - Insert interval and merge if needed
29. **Jump Game** - Check if can reach last index
30. **Unique Paths** - Count paths in grid from top-left to bottom-right
31. **Set Matrix Zeroes** - Set entire row/column to zero
32. **Search a 2D Matrix** - Binary search in sorted matrix
33. **Minimum Path Sum** - Find minimum sum path in grid
34. **Word Search** - Find word in 2D board using backtracking
35. **Combination Sum** - Find combinations that sum to target

### Hard (36-50)
36. **Trapping Rain Water** - Calculate trapped rainwater
37. **First Missing Positive** - Find smallest missing positive integer
38. **Jump Game II** - Minimum jumps to reach end
39. **Median of Two Sorted Arrays** - Find median in O(log(min(m,n)))
40. **Largest Rectangle in Histogram** - Find largest rectangle area
41. **Maximal Rectangle** - Find largest rectangle in binary matrix
42. **Sliding Window Maximum** - Maximum in each window of size k
43. **Minimum Window Substring** - Smallest window containing all chars
44. **Longest Consecutive Sequence** - Find longest consecutive sequence
45. **Best Time to Buy and Sell Stock III** - At most 2 transactions
46. **Candy** - Minimum candies distribution problem
47. **Count of Smaller Numbers After Self** - Count smaller elements to right
48. **Maximum Gap** - Maximum difference between successive elements
49. **Reverse Pairs** - Count pairs where i < j and nums[i] > 2*nums[j]
50. **Shortest Subarray with Sum at Least K** - Find shortest subarray

---

## Strings (50 Questions)

### Easy (1-15)
1. **Valid Palindrome** - Check if string is palindrome ignoring case
2. **Reverse String** - Reverse string in-place
3. **First Unique Character** - Find first non-repeating character
4. **Valid Anagram** - Check if two strings are anagrams
5. **Implement strStr()** - Find needle in haystack
6. **Length of Last Word** - Return length of last word
7. **Longest Common Prefix** - Find longest common prefix
8. **Add Binary** - Add two binary strings
9. **Reverse Words in String III** - Reverse each word individually
10. **Detect Capital** - Check if capitals are used correctly
11. **Ransom Note** - Check if ransom note can be constructed
12. **Isomorphic Strings** - Check if strings are isomorphic
13. **Word Pattern** - Check if string follows pattern
14. **Valid Parentheses** - Check if parentheses are balanced
15. **Remove Duplicates from String** - Remove duplicate characters

### Medium (16-35)
16. **Longest Substring Without Repeating Characters** - Find longest unique substring
17. **Longest Palindromic Substring** - Find longest palindrome
18. **Group Anagrams** - Group strings by anagrams
19. **Generate Parentheses** - Generate all valid parentheses combinations
20. **Letter Combinations of Phone Number** - Generate letter combinations
21. **Multiply Strings** - Multiply two non-negative integers as strings
22. **Zigzag Conversion** - Convert string to zigzag pattern
23. **String to Integer (atoi)** - Convert string to integer
24. **Count and Say** - Generate count-and-say sequence
25. **Decode Ways** - Count ways to decode string
26. **Restore IP Addresses** - Generate all valid IP addresses
27. **Palindrome Partitioning** - Partition string into palindromes
28. **Word Break** - Check if string can be segmented
29. **Minimum Window Substring** - Find minimum window containing all chars
30. **Substring with Concatenation of All Words** - Find all starting indices
31. **Longest Repeating Character Replacement** - Longest substring with same char
32. **Find All Anagrams in String** - Find all anagram starting positions
33. **Permutation in String** - Check if string contains permutation
34. **Reorganize String** - Reorganize so no two same chars adjacent
35. **Custom Sort String** - Sort string based on custom order

### Hard (36-50)
36. **Edit Distance** - Minimum operations to convert one string to another
37. **Regular Expression Matching** - Implement regex matching
38. **Wildcard Matching** - Implement wildcard pattern matching
39. **Longest Valid Parentheses** - Find longest valid parentheses substring
40. **Scramble String** - Check if string is scrambled version
41. **Interleaving String** - Check if string is interleaving of two strings
42. **Distinct Subsequences** - Count distinct subsequences
43. **Palindrome Partitioning II** - Minimum cuts for palindrome partitioning
44. **Word Ladder** - Find shortest transformation sequence
45. **Word Ladder II** - Find all shortest transformation sequences
46. **Concatenated Words** - Find all concatenated words
47. **Shortest Palindrome** - Find shortest palindrome by adding chars
48. **Valid Number** - Check if string represents valid number
49. **Remove Invalid Parentheses** - Remove minimum parentheses to make valid
50. **Alien Dictionary** - Find order of characters in alien language

---

## Linked Lists (50 Questions)

### Easy (1-15)
1. **Reverse Linked List** - Reverse singly linked list
2. **Merge Two Sorted Lists** - Merge two sorted linked lists
3. **Remove Duplicates from Sorted List** - Remove duplicates from sorted list
4. **Linked List Cycle** - Detect if linked list has cycle
5. **Intersection of Two Linked Lists** - Find intersection point
6. **Remove Linked List Elements** - Remove all nodes with given value
7. **Palindrome Linked List** - Check if linked list is palindrome
8. **Middle of Linked List** - Find middle node
9. **Convert Binary Number to Integer** - Convert binary linked list to integer
10. **Delete Node in Linked List** - Delete node when only given node
11. **Merge k Sorted Lists** - Merge k sorted linked lists
12. **Add Two Numbers** - Add numbers represented as linked lists
13. **Swap Nodes in Pairs** - Swap every two adjacent nodes
14. **Remove Nth Node From End** - Remove nth node from end
15. **Copy List with Random Pointer** - Deep copy list with random pointers

### Medium (16-35)
16. **Add Two Numbers II** - Add numbers with most significant digit first
17. **Odd Even Linked List** - Group odd and even positioned nodes
18. **Rotate List** - Rotate list to right by k places
19. **Partition List** - Partition list around value x
20. **Sort List** - Sort linked list in O(n log n)
21. **Reorder List** - Reorder list in specific pattern
22. **Linked List Cycle II** - Find start of cycle in linked list
23. **Remove Duplicates from Sorted List II** - Remove all duplicates
24. **Reverse Nodes in k-Group** - Reverse nodes in groups of k
25. **Flatten Multilevel Doubly Linked List** - Flatten multilevel list
26. **Insert into Sorted Circular Linked List** - Insert into circular list
27. **Split Linked List in Parts** - Split list into k parts
28. **Next Greater Node in Linked List** - Find next greater element
29. **Linked List Components** - Count connected components
30. **Design Linked List** - Implement your own linked list
31. **Double a Number Represented as Linked List** - Double the number
32. **Merge In Between Linked Lists** - Merge list b into list a
33. **Swapping Nodes in Linked List** - Swap nodes by position
34. **Remove Zero Sum Consecutive Nodes** - Remove zero sum sublists
35. **Convert Sorted List to Binary Search Tree** - Convert to balanced BST

### Hard (36-50)
36. **Reverse Nodes in Even Length Groups** - Reverse even length groups
37. **All O(1) Data Structure** - Implement O(1) insert, delete, getRandom
38. **LRU Cache** - Implement Least Recently Used cache
39. **LFU Cache** - Implement Least Frequently Used cache
40. **Design Browser History** - Implement browser history with back/forward
41. **Flatten Binary Tree to Linked List** - Flatten tree to linked list
42. **Clone Graph** - Deep clone connected graph
43. **Serialize and Deserialize Binary Tree** - Using linked list representation
44. **Design Skip List** - Implement skip list data structure
45. **Merge k Sorted Lists** - Efficient solution using heap
46. **Maximum Twin Sum of Linked List** - Find maximum twin sum
47. **Linked List Random Node** - Get random node with equal probability
48. **Delete Nodes and Return Forest** - Delete nodes and return forest
49. **Minimum Number of Taps** - Garden watering problem
50. **Critical Connections in Network** - Find bridges in graph

---

## Trees (50 Questions)

### Easy (1-15)
1. **Maximum Depth of Binary Tree** - Find maximum depth
2. **Same Tree** - Check if two trees are identical
3. **Invert Binary Tree** - Invert/flip binary tree
4. **Symmetric Tree** - Check if tree is symmetric
5. **Binary Tree Paths** - Find all root-to-leaf paths
6. **Path Sum** - Check if root-to-leaf path equals sum
7. **Minimum Depth of Binary Tree** - Find minimum depth
8. **Balanced Binary Tree** - Check if tree is height-balanced
9. **Diameter of Binary Tree** - Find diameter of tree
10. **Merge Two Binary Trees** - Merge trees by adding values
11. **Binary Tree Tilt** - Calculate tilt of tree
12. **Second Minimum Node** - Find second minimum value
13. **Average of Levels** - Calculate average at each level
14. **Two Sum IV - Input is BST** - Find two numbers that sum to target
15. **Range Sum of BST** - Sum values in given range

### Medium (16-35)
16. **Binary Tree Inorder Traversal** - Iterative inorder traversal
17. **Binary Tree Level Order Traversal** - Level order using queue
18. **Zigzag Level Order Traversal** - Traverse in zigzag pattern
19. **Construct Binary Tree from Preorder and Inorder** - Build tree from traversals
20. **Construct Binary Tree from Inorder and Postorder** - Build tree from traversals
21. **Populating Next Right Pointers** - Connect nodes at same level
22. **Flatten Binary Tree to Linked List** - Flatten to linked list
23. **Path Sum II** - Find all root-to-leaf paths with sum
24. **Binary Tree Right Side View** - View from right side
25. **Count Complete Tree Nodes** - Count nodes in complete tree
26. **Lowest Common Ancestor** - Find LCA in binary tree
27. **Validate Binary Search Tree** - Check if valid BST
28. **Recover Binary Search Tree** - Fix swapped nodes in BST
29. **Convert Sorted Array to BST** - Build balanced BST
30. **Convert BST to Greater Tree** - Convert to greater sum tree
31. **Binary Tree Pruning** - Remove subtrees with all zeros
32. **All Possible Full Binary Trees** - Generate all full binary trees
33. **Distribute Coins in Binary Tree** - Minimum moves to distribute coins
34. **Maximum Binary Tree** - Construct maximum binary tree
35. **Find Duplicate Subtrees** - Find all duplicate subtrees

### Hard (36-50)
36. **Serialize and Deserialize Binary Tree** - Convert tree to/from string
37. **Binary Tree Maximum Path Sum** - Find maximum path sum
38. **Recover Binary Search Tree** - Fix two swapped nodes
39. **Count of Smaller Numbers After Self** - Using BST
40. **Vertical Order Traversal** - Traverse in vertical order
41. **Binary Tree Cameras** - Minimum cameras to monitor all nodes
42. **House Robber III** - Maximum money without robbing connected nodes
43. **Longest Univalue Path** - Find longest path with same values
44. **Binary Tree Postorder Traversal** - Iterative postorder
45. **Sum of Distances in Tree** - Sum of distances for each node
46. **All Nodes Distance K** - Find all nodes at distance K
47. **Smallest Subtree with Deepest Nodes** - Find smallest subtree
48. **Maximum Width of Binary Tree** - Find maximum width
49. **Minimum Height Trees** - Find roots of minimum height trees
50. **Binary Tree Coloring Game** - Tree coloring strategy game

---

## Graphs (50 Questions)

### Easy (1-15)
1. **Find if Path Exists in Graph** - Check if path exists between nodes
2. **Find Center of Star Graph** - Find center node in star graph
3. **Find the Town Judge** - Find person who is trusted by everyone
4. **Number of Provinces** - Count connected components
5. **Flood Fill** - Implement flood fill algorithm
6. **Max Area of Island** - Find maximum area of island
7. **Island Perimeter** - Calculate perimeter of island
8. **Minimum Depth of Binary Tree** - BFS approach
9. **Employee Importance** - Calculate total importance using DFS/BFS
10. **N-ary Tree Level Order Traversal** - Level order traversal
11. **Minimum Genetic Mutation** - Minimum mutations using BFS
12. **Find Eventual Safe States** - Find safe nodes in directed graph
13. **All Paths from Source to Target** - Find all paths in DAG
14. **Keys and Rooms** - Check if all rooms can be visited
15. **Rotting Oranges** - Minimum time for all oranges to rot

### Medium (16-35)
16. **Number of Islands** - Count islands using DFS/BFS
17. **Clone Graph** - Deep clone undirected graph
18. **Course Schedule** - Detect cycle in directed graph
19. **Course Schedule II** - Topological sort
20. **Pacific Atlantic Water Flow** - Water flow to both oceans
21. **Number of Distinct Islands** - Count unique island shapes
22. **Surrounded Regions** - Capture surrounded regions
23. **Word Ladder** - Shortest transformation sequence
24. **Minimum Height Trees** - Find roots of minimum height trees
25. **Graph Valid Tree** - Check if edges form valid tree
26. **Network Delay Time** - Shortest path using Dijkstra
27. **Cheapest Flights Within K Stops** - Modified Dijkstra with constraints
28. **Redundant Connection** - Find edge that makes cycle
29. **Accounts Merge** - Merge accounts using Union-Find
30. **Most Stones Removed** - Maximum stones that can be removed
31. **Satisfiability of Equality Equations** - Check equation satisfiability
32. **Possible Bipartition** - Check if graph is bipartite
33. **Shortest Path in Binary Matrix** - Find shortest path in matrix
34. **As Far from Land as Possible** - Find cell farthest from land
35. **Time Needed to Inform All Employees** - Information propagation time

### Hard (36-50)
36. **Word Ladder II** - Find all shortest transformation sequences
37. **Alien Dictionary** - Find character order in alien language
38. **Critical Connections in Network** - Find bridges in network
39. **Minimum Cost to Connect All Points** - Minimum spanning tree
40. **Swim in Rising Water** - Binary search with DFS/BFS
41. **Bus Routes** - Minimum bus routes to reach destination
42. **Shortest Path Visiting All Nodes** - TSP variant using bitmask
43. **Reconstruct Itinerary** - Find Eulerian path
44. **Making Large Island** - Maximum island after changing one cell
45. **Sliding Puzzle** - Solve sliding puzzle using BFS
46. **Escape Large Maze** - Check if escape is possible
47. **Minimum Number of Taps** - Interval covering problem
48. **Find All People With Secret** - Information propagation with timing
49. **Parallel Courses III** - Longest path in DAG with weights
50. **Race Car** - Minimum instructions to reach target

---

## Dynamic Programming (50 Questions)

### Easy (1-15)
1. **Climbing Stairs** - Count ways to climb n stairs
2. **House Robber** - Maximum money without robbing adjacent houses
3. **Maximum Subarray** - Find contiguous subarray with maximum sum
4. **Best Time to Buy and Sell Stock** - Maximum profit from one transaction
5. **Range Sum Query - Immutable** - Prefix sum for range queries
6. **Counting Bits** - Count 1s in binary representation
7. **Min Cost Climbing Stairs** - Minimum cost to reach top
8. **Divisor Game** - Optimal game strategy
9. **Fibonacci Number** - Calculate nth Fibonacci number
10. **N-th Tribonacci Number** - Calculate nth Tribonacci number
11. **Pascal's Triangle** - Generate Pascal's triangle
12. **Is Subsequence** - Check if string is subsequence
13. **Delete and Earn** - Maximum points by deleting numbers
14. **Minimum Path Sum** - Find minimum sum path in grid
15. **Unique Paths** - Count paths from top-left to bottom-right

### Medium (16-35)
16. **Coin Change** - Minimum coins to make amount
17. **Longest Increasing Subsequence** - Find LIS length
18. **Word Break** - Check if string can be segmented
19. **Combination Sum IV** - Count combinations that sum to target
20. **House Robber II** - Houses arranged in circle
21. **Decode Ways** - Count ways to decode string
22. **Unique Paths II** - Paths with obstacles
23. **Jump Game** - Check if can reach last index
24. **Partition Equal Subset Sum** - Check if can partition into equal sum
25. **Target Sum** - Count ways to reach target sum
26. **Perfect Squares** - Minimum perfect squares to sum to n
27. **Coin Change 2** - Number of ways to make amount
28. **Longest Palindromic Subsequence** - Find LPS length
29. **Palindromic Substrings** - Count palindromic substrings
30. **Longest Common Subsequence** - Find LCS length
31. **Edit Distance** - Minimum operations to convert strings
32. **Maximum Product Subarray** - Find contiguous subarray with max product
33. **Wiggle Subsequence** - Find longest wiggle subsequence
34. **Integer Break** - Break integer to maximize product
35. **Counting Bits** - Count 1s for numbers 0 to n

### Hard (36-50)
36. **Regular Expression Matching** - Implement regex matching
37. **Wildcard Matching** - Implement wildcard pattern matching
38. **Longest Valid Parentheses** - Find longest valid parentheses
39. **Maximal Rectangle** - Find largest rectangle in binary matrix
40. **Best Time to Buy and Sell Stock III** - At most 2 transactions
41. **Best Time to Buy and Sell Stock IV** - At most k transactions
42. **Burst Balloons** - Maximum coins by bursting balloons
43. **Stone Game** - Optimal game strategy
44. **Predict the Winner** - Game theory with optimal play
45. **Palindrome Partitioning II** - Minimum cuts for palindrome partitioning
46. **Scramble String** - Check if string is scrambled version
47. **Interleaving String** - Check if string is interleaving
48. **Distinct Subsequences** - Count distinct subsequences
49. **Minimum Insertion Steps** - Make string palindrome
50. **Maximum Profit in Job Scheduling** - Weighted job scheduling

---

## Backtracking (50 Questions)

### Easy (1-15)
1. **Generate Parentheses** - Generate all valid parentheses
2. **Letter Combinations of Phone Number** - Generate letter combinations
3. **Subsets** - Generate all subsets
4. **Combination Sum** - Find combinations that sum to target
5. **Permutations** - Generate all permutations
6. **Combinations** - Generate all combinations of k elements
7. **Palindrome Partitioning** - Partition string into palindromes
8. **Word Search** - Find word in 2D board
9. **Restore IP Addresses** - Generate all valid IP addresses
10. **Binary Watch** - Generate times with k LEDs on
11. **Find Unique Binary String** - Find binary string not in array
12. **Fair Distribution of Cookies** - Distribute cookies fairly
13. **Split String into Max Number of Pieces** - Split into unique substrings
14. **Partition to K Equal Sum Subsets** - Check if can partition
15. **Beautiful Arrangement** - Count beautiful arrangements

### Medium (16-35)
16. **Subsets II** - Generate subsets with duplicates
17. **Permutations II** - Generate permutations with duplicates
18. **Combination Sum II** - Combinations with duplicates
19. **Combination Sum III** - Combinations with k numbers
20. **Gray Code** - Generate Gray code sequence
21. **Word Search II** - Find all words in board using Trie
22. **Additive Number** - Check if string is additive number
23. **Factor Combinations** - Find all factor combinations
24. **Remove Invalid Parentheses** - Remove minimum parentheses
25. **Generalized Abbreviation** - Generate all abbreviations
26. **Letter Case Permutation** - Generate permutations by changing case
27. **Partition Labels** - Partition string into maximum parts
28. **Matchsticks to Square** - Check if can form square
29. **Optimal Account Balancing** - Minimize transactions
30. **Strobogrammatic Number II** - Generate strobogrammatic numbers
31. **Count Numbers with Unique Digits** - Count unique digit numbers
32. **Sudoku Solver** - Solve Sudoku using backtracking
33. **N-Queens** - Place N queens on chessboard
34. **Increasing Subsequences** - Find all increasing subsequences
35. **Shopping Offers** - Minimum cost with special offers

### Hard (36-50)
36. **N-Queens II** - Count solutions for N-Queens
37. **Sudoku Solver** - Solve 9x9 Sudoku puzzle
38. **Word Break II** - Find all possible sentences
39. **Palindrome Partitioning II** - Minimum cuts with backtracking
40. **Concatenated Words** - Find concatenated words
41. **Expression Add Operators** - Add operators to reach target
42. **Android Unlock Patterns** - Count unlock patterns
43. **Wildcard Matching** - Backtracking approach
44. **Regular Expression Matching** - Backtracking approach
45. **Word Squares** - Build word squares
46. **Verbal Arithmetic Puzzle** - Solve cryptarithmetic puzzle
47. **Maximum Length of Concatenated String** - Unique characters
48. **Minimum Unique Word Abbreviation** - Find shortest abbreviation
49. **Zuma Game** - Minimum balls to clear board
50. **24 Game** - Check if can reach 24 with operations

---

## Heap/Priority Queue (50 Questions)

### Easy (1-15)
1. **Kth Largest Element in Array** - Find kth largest using heap
2. **Last Stone Weight** - Simulate stone smashing
3. **Relative Ranks** - Assign ranks to athletes
4. **K Closest Points to Origin** - Find k closest points
5. **Top K Frequent Elements** - Find k most frequent elements
6. **Meeting Rooms** - Check if person can attend all meetings
7. **Merge k Sorted Lists** - Merge using min heap
8. **Find Median from Data Stream** - Maintain median dynamically
9. **Kth Smallest Element in Sorted Matrix** - Find kth smallest
10. **Ugly Number II** - Find nth ugly number
11. **Super Ugly Number** - Generalized ugly number
12. **Find K Pairs with Smallest Sums** - Find k pairs with min sum
13. **Third Maximum Number** - Find third maximum using heap
14. **Design Twitter** - Design social media feed
15. **Reorganize String** - Reorganize to avoid adjacent duplicates

### Medium (16-35)
16. **Top K Frequent Words** - Find k most frequent words
17. **Kth Smallest Element in BST** - Find kth smallest in BST
18. **Sort Characters by Frequency** - Sort by character frequency
19. **Task Scheduler** - Schedule tasks with cooling time
20. **Meeting Rooms II** - Minimum meeting rooms needed
21. **Sliding Window Maximum** - Maximum in sliding window
22. **Find Right Interval** - Find right interval for each interval
23. **Minimum Cost to Hire K Workers** - Minimum cost with constraints
24. **Campus Bikes** - Assign bikes to workers optimally
25. **Advantage Shuffle** - Rearrange to maximize advantage
26. **Hand of Straights** - Check if can form consecutive groups
27. **Distant Barcodes** - Rearrange to avoid adjacent same codes
28. **Minimum Number of Refueling Stops** - Minimum stops to reach target
29. **Car Pooling** - Check if car can handle all trips
30. **Maximum Performance of Team** - Select team with max performance
31. **Smallest Range Covering Elements** - Find smallest range from k lists
32. **Rearrange String k Distance Apart** - Rearrange with distance constraint
33. **Design Hit Counter** - Design hit counter with time window
34. **Sequence Reconstruction** - Check if sequence can be reconstructed
35. **Alien Dictionary** - Find character order using topological sort

### Hard (36-50)
36. **Median of Two Sorted Arrays** - Find median efficiently
37. **Sliding Window Median** - Median in sliding window
38. **IPO** - Maximize capital with project selection
39. **Swim in Rising Water** - Find minimum time to reach destination
40. **Shortest Path to Get All Keys** - Collect all keys optimally
41. **Minimum Cost to Make Array Non-decreasing** - Transform array optimally
42. **Process Tasks Using Servers** - Assign tasks to servers
43. **Maximum Number of Events That Can Be Attended** - Attend maximum events
44. **Maximum Frequency Stack** - Design frequency-based stack
45. **Minimum Interval to Include Each Query** - Find minimum intervals
46. **Find Servers That Handled Most Requests** - Server load balancing
47. **Minimum Number of Taps to Open** - Garden watering optimization
48. **Minimum Cost to Connect Sticks** - Connect sticks optimally
49. **Trapping Rain Water II** - 2D version of trapping rainwater
50. **The Skyline Problem** - Building skyline using sweep line

---

## Binary Search (50 Questions)

### Easy (1-15)
1. **Binary Search** - Classic binary search implementation
2. **Search Insert Position** - Find position to insert target
3. **First Bad Version** - Find first bad version
4. **Sqrt(x)** - Integer square root using binary search
5. **Valid Perfect Square** - Check if number is perfect square
6. **Guess Number Higher or Lower** - Guessing game
7. **Intersection of Two Arrays** - Find intersection using binary search
8. **Two Sum II - Input Array is Sorted** - Two pointers approach
9. **Arranging Coins** - Find complete rows that can be formed
10. **Find Smallest Letter Greater Than Target** - Circular sorted array
11. **Peak Index in Mountain Array** - Find peak in mountain array
12. **Kth Missing Positive Number** - Find kth missing positive
13. **Binary Search in Rotated Sorted Array** - Search in rotated array
14. **Find Minimum in Rotated Sorted Array** - Find minimum element
15. **Search in Rotated Sorted Array II** - With duplicates

### Medium (16-35)
16. **Find First and Last Position** - Find range of target value
17. **Search in Rotated Sorted Array** - Classic rotated array search
18. **Find Peak Element** - Find any peak element
19. **Search a 2D Matrix** - Binary search in 2D matrix
20. **Search a 2D Matrix II** - Sorted matrix search
21. **Kth Smallest Element in Sorted Matrix** - Find kth smallest
22. **Find Right Interval** - Find smallest interval to the right
23. **Random Pick with Weight** - Weighted random selection
24. **Online Election** - Find leader at given time
25. **Capacity to Ship Packages** - Minimum capacity needed
26. **Koko Eating Bananas** - Minimum eating speed
27. **Minimum Number of Days to Make Bouquets** - Flower arrangement
28. **Magnetic Force Between Two Balls** - Maximize minimum distance
29. **Most Competitive Subsequence** - Find lexicographically smallest
30. **Find Kth Smallest Pair Distance** - Kth smallest distance
31. **Split Array Largest Sum** - Minimize largest sum
32. **Divide Chocolate** - Maximize minimum sweetness
33. **Minimum Time to Complete Trips** - Minimum time calculation
34. **Maximum Running Time of N Computers** - Battery allocation
35. **Minimum Speed to Arrive on Time** - Calculate minimum speed

### Hard (36-50)
36. **Median of Two Sorted Arrays** - Find median in O(log(min(m,n)))
37. **Find Minimum in Rotated Sorted Array II** - With duplicates
38. **Count of Smaller Numbers After Self** - Using binary indexed tree
39. **Russian Doll Envelopes** - Longest increasing subsequence 2D
40. **Count of Range Sum** - Count range sums in array
41. **Longest Duplicate Substring** - Find longest duplicate using rolling hash
42. **Minimum Distance to Type Word** - Optimal typing distance
43. **Find in Mountain Array** - Search in mountain array
44. **Maximum Side Length of Square** - Largest square with sum ≤ threshold
45. **Minimum Number of Taps** - Water garden optimally
46. **Nth Magical Number** - Find nth number divisible by A or B
47. **Preimage Size of Factorial Zeroes** - Count numbers with k trailing zeros
48. **Maximum Average Subarray II** - Maximum average of length ≥ k
49. **Smallest Rectangle Enclosing Black Pixels** - Find bounding rectangle
50. **Find K-th Smallest Pair Distance** - Advanced pair distance problem

---

## Sliding Window (50 Questions)

### Easy (1-15)
1. **Maximum Average Subarray I** - Maximum average of length k
2. **Contains Duplicate II** - Check duplicates within k distance
3. **Maximum Number of Vowels** - Maximum vowels in substring of length k
4. **Get Equal Substrings Within Budget** - Maximum length within budget
5. **Defanging an IP Address** - Replace dots with [.]
6. **Find All Anagrams in String** - Find all anagram starting positions
7. **Minimum Window Substring** - Smallest window containing all characters
8. **Permutation in String** - Check if string contains permutation
9. **Longest Substring Without Repeating Characters** - Find longest unique substring
10. **Minimum Size Subarray Sum** - Minimum length subarray with sum ≥ target
11. **Fruit Into Baskets** - Maximum fruits in two baskets
12. **Max Consecutive Ones III** - Maximum consecutive 1s after flipping k zeros
13. **Binary Subarrays With Sum** - Count subarrays with given sum
14. **Subarrays with K Different Integers** - Count subarrays with exactly k distinct
15. **Sliding Window Maximum** - Maximum in each window of size k

### Medium (16-35)
16. **Longest Repeating Character Replacement** - Longest substring with same character
17. **Longest Substring with At Most Two Distinct Characters** - Two distinct characters
18. **Longest Substring with At Most K Distinct Characters** - K distinct characters
19. **Minimum Operations to Reduce X to Zero** - Minimum operations from both ends
20. **Grumpy Bookstore Owner** - Maximize satisfied customers
21. **Replace the Substring for Balanced String** - Balance string optimally
22. **Count Number of Nice Subarrays** - Count subarrays with k odd numbers
23. **Longest Subarray of 1s After Deleting One Element** - Maximum 1s after deletion
24. **Maximum Points from Cards** - Maximum points from k cards
25. **Minimum Window Subsequence** - Minimum window containing subsequence
26. **Substring with Concatenation of All Words** - Find all starting indices
27. **Minimum Number of K Consecutive Bit Flips** - Minimum flips needed
28. **Shortest Subarray with Sum at Least K** - Shortest subarray with sum ≥ k
29. **Maximum Sum of Almost Unique Subarray** - Subarray with at most k distinct
30. **Constrained Subsequence Sum** - Maximum sum with constraint
31. **Get Biggest Three Rhombus Sums** - Find three largest rhombus sums
32. **Minimum Adjacent Swaps for K Consecutive Ones** - Group consecutive ones
33. **Frequency of Most Frequent Element** - Maximum frequency after operations
34. **Maximize Score After N Operations** - Maximize GCD sum
35. **Minimum Number of Operations to Make Array Continuous** - Make array continuous

### Hard (36-50)
36. **Sliding Window Median** - Find median in sliding window
37. **Minimum Window Substring** - Advanced version with multiple constraints
38. **Substring with Concatenation of All Words** - Complex pattern matching
39. **Longest Valid Parentheses** - Longest valid parentheses using sliding window
40. **Max Value of Equation** - Maximum value with sliding window optimization
41. **Constrained Subsequence Sum** - Dynamic programming with sliding window
42. **Shortest Subarray with Sum at Least K** - Using deque optimization
43. **Subarrays with K Different Integers** - Exactly k distinct elements
44. **Number of Substrings Containing All Three Characters** - Count valid substrings
45. **Count Subarrays with Fixed Bounds** - Count subarrays within bounds
46. **Minimum Number of Taps to Open** - Garden watering with sliding window
47. **Maximum Number of Robots Within Budget** - Robot budget optimization
48. **Minimum Replacements to Sort Array** - Sort with minimum replacements
49. **Count Vowel Strings in Ranges** - Range queries with sliding window
50. **Maximum Number of Non-overlapping Subarrays** - Non-overlapping with target sum

---

## Two Pointers (50 Questions)

### Easy (1-15)
1. **Two Sum II - Input Array is Sorted** - Find two numbers that sum to target
2. **Valid Palindrome** - Check if string is palindrome
3. **Remove Duplicates from Sorted Array** - Remove duplicates in-place
4. **Move Zeroes** - Move all zeros to end
5. **Reverse String** - Reverse string using two pointers
6. **Intersection of Two Arrays II** - Find intersection with duplicates
7. **Merge Sorted Array** - Merge two sorted arrays
8. **Remove Element** - Remove all instances of value
9. **Squares of Sorted Array** - Square elements and sort
10. **Backspace String Compare** - Compare strings with backspaces
11. **Long Pressed Name** - Check if name was long pressed
12. **Partition Labels** - Partition string into maximum parts
13. **Reverse Only Letters** - Reverse only alphabetic characters
14. **Sort Array by Parity** - Move even numbers to front
15. **Flipping an Image** - Flip and invert binary matrix

### Medium (16-35)
16. **3Sum** - Find all unique triplets that sum to zero
17. **3Sum Closest** - Find triplet closest to target
18. **4Sum** - Find all unique quadruplets that sum to target
19. **Container With Most Water** - Find container with most water
20. **Trapping Rain Water** - Calculate trapped rainwater
21. **Sort Colors** - Sort array of 0s, 1s, and 2s
22. **Remove Duplicates from Sorted Array II** - Allow at most 2 duplicates
23. **Minimum Size Subarray Sum** - Minimum length subarray with sum ≥ target
24. **3Sum Smaller** - Count triplets with sum less than target
25. **Valid Triangle Number** - Count valid triangles
26. **Two Sum IV - Input is BST** - Two sum in BST
27. **Boats to Save People** - Minimum boats needed
28. **Push Dominoes** - Simulate falling dominoes
29. **Shortest Distance to Character** - Distance to target character
30. **Fruit Into Baskets** - Maximum fruits in two types
31. **Subarrays with K Different Integers** - Exactly k different integers
32. **Interval List Intersections** - Find intersections of two interval lists
33. **Camelcase Matching** - Pattern matching with camelcase
34. **Comparing Strings by Frequency of Smallest Character** - String comparison
35. **Number of Subsequences That Satisfy Sum Condition** - Count valid subsequences

### Hard (36-50)
36. **Trapping Rain Water II** - 2D version of trapping rainwater
37. **Sliding Window Maximum** - Maximum in sliding window using deque
38. **Minimum Window Substring** - Smallest window containing all characters
39. **Longest Substring with At Most K Distinct Characters** - K distinct characters
40. **Subarrays with K Different Integers** - Advanced two pointers technique
41. **Count of Smaller Numbers After Self** - Using merge sort approach
42. **Reverse Pairs** - Count reverse pairs efficiently
43. **Max Chunks To Make Sorted II** - Maximum chunks to sort array
44. **Shortest Subarray with Sum at Least K** - Efficient subarray finding
45. **Minimum Operations to Make Array Equal** - Minimum operations needed
46. **Count Number of Teams** - Count increasing/decreasing subsequences
47. **Stone Game III** - Optimal game strategy with three choices
48. **Minimum Difference Between Largest and Smallest Value** - Minimize range
49. **Maximum Number of Visible Points** - Geometry with two pointers
50. **Maximize Distance to Closest Person** - Optimal seating arrangement

---

## Java Implementation Examples

### Arrays - Two Sum (Easy)
```java
public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        if (map.containsKey(complement)) {
            return new int[]{map.get(complement), i};
        }
        map.put(nums[i], i);
    }
    return new int[]{};
}
```

### Linked Lists - Reverse Linked List
```java
public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode current = head;
    
    while (current != null) {
        ListNode next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }
    
    return prev;
}
```

### Trees - Maximum Depth
```java
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}
```

### Dynamic Programming - Climbing Stairs
```java
public int climbStairs(int n) {
    if (n <= 2) return n;
    
    int[] dp = new int[n + 1];
    dp[1] = 1;
    dp[2] = 2;
    
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
}
```

---

## C++ Implementation Examples

### Arrays - Two Sum (Easy)
```cpp
vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> map;
    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        if (map.find(complement) != map.end()) {
            return {map[complement], i};
        }
        map[nums[i]] = i;
    }
    return {};
}
```

### Linked Lists - Reverse Linked List
```cpp
ListNode* reverseList(ListNode* head) {
    ListNode* prev = nullptr;
    ListNode* current = head;
    
    while (current != nullptr) {
        ListNode* next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }
    
    return prev;
}
```

### Trees - Maximum Depth
```cpp
int maxDepth(TreeNode* root) {
    if (root == nullptr) return 0;
    return 1 + max(maxDepth(root->left), maxDepth(root->right));
}
```

### Binary Search - Binary Search
```cpp
int search(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return mid;
        else if (nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    
    return -1;
}
```

---

## Company-Specific Focus Areas

### Google
- **Primary Focus**: Arrays, Strings, Trees, Dynamic Programming
- **Key Patterns**: Two pointers, sliding window, DFS/BFS, backtracking
- **Difficulty**: Medium to Hard
- **Interview Style**: Clean code, edge cases, optimization

### Microsoft
- **Primary Focus**: Arrays, Linked Lists, Trees, Dynamic Programming
- **Key Patterns**: Recursion, iteration, system design integration
- **Difficulty**: Easy to Hard
- **Interview Style**: Practical solutions, scalability discussion

### Amazon
- **Primary Focus**: Arrays, Trees, Graphs, Dynamic Programming
- **Key Patterns**: BFS/DFS, two pointers, greedy algorithms
- **Difficulty**: Medium focus
- **Interview Style**: Leadership principles integration, real-world scenarios

### Apple
- **Primary Focus**: Arrays, Strings, Trees, System Design
- **Key Patterns**: Optimization, memory efficiency, clean architecture
- **Difficulty**: Medium to Hard
- **Interview Style**: Product-focused discussions, user experience

### Atlassian
- **Primary Focus**: Arrays, Strings, Graphs, Design Patterns
- **Key Patterns**: Graph algorithms, string manipulation, system design
- **Difficulty**: Easy to Medium
- **Interview Style**: Collaborative problem solving, team fit

### Adobe
- **Primary Focus**: Arrays, Strings, Dynamic Programming, Geometry
- **Key Patterns**: String processing, algorithm optimization, mathematical problems
- **Difficulty**: Medium to Hard
- **Interview Style**: Creative problem solving, visual thinking

### Samsung
- **Primary Focus**: Arrays, Dynamic Programming, Mathematical Problems
- **Key Patterns**: Optimization algorithms, mathematical solutions, efficiency
- **Difficulty**: Medium focus
- **Interview Style**: Technical depth, algorithm efficiency

---

## Study Plan Recommendations

### Week 1-2: Foundation
- Arrays (Easy: 1-15, Medium: 16-25)
- Strings (Easy: 1-15, Medium: 16-25)
- Basic Two Pointers and Sliding Window

### Week 3-4: Core Data Structures
- Linked Lists (Easy: 1-15, Medium: 16-25)
- Trees (Easy: 1-15, Medium: 16-25)
- Basic Graph Problems

### Week 5-6: Advanced Patterns
- Dynamic Programming (Easy: 1-15, Medium: 16-25)
- Backtracking (Easy: 1-15, Medium: 16-20)
- Binary Search (Easy: 1-15, Medium: 16-20)

### Week 7-8: Mastery and Hard Problems
- Hard problems from each category
- Company-specific problem sets
- Mock interviews and time management

### Daily Practice Schedule
- **Morning (1 hour)**: 2 Easy problems
- **Evening (1.5 hours)**: 1 Medium + 1 review
- **Weekend**: 2 Hard problems + comprehensive review

### Key Success Metrics
- **Week 1-2**: 70% accuracy on Easy problems
- **Week 3-4**: 60% accuracy on Medium problems  
- **Week 5-6**: 50% accuracy on Hard problems
- **Week 7-8**: Consistent performance across all levels